#!/usr/bin/env python3
import yaml
import json
import os
import sys
from datetime import datetime

TAG_INDEX_PATH = "meta/tag_index.yml"
OUTPUT_PATH = "docs/graph_data.js"

def load_tag_index(path):
    with open(path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    # Accept both modern "dict-of-tags" and legacy "list" formats.
    # Modern (recommended) shape seen in your repo:
    # {
    #   "RGP": {"links":[...], "pulses":[...], ...},
    #   "NT":  {"links":[...], ...},
    #   ...
    # }
    #
    # Legacy tolerated shape:
    # [
    #   {"tag":"RGP","links":[...],"centrality":...},
    #   "LooseStringTag"
    # ]
    if isinstance(data, dict):
        # Normalize into list of {tag, links, centrality?}
        entries = []
        for tag, obj in data.items():
            if not isinstance(obj, dict):
                obj = {}
            links = obj.get("links", []) or []
            # If centrality not provided, use out-degree as a simple proxy
            centrality = obj.get("centrality", float(len(links)))
            entries.append({"tag": str(tag), "links": list(map(str, links)), "centrality": float(centrality)})
        return entries

    elif isinstance(data, list):
        entries = []
        for item in data:
            if isinstance(item, str):
                entries.append({"tag": item, "links": [], "centrality": 0.0})
            elif isinstance(item, dict):
                tag = item.get("tag")
                if not tag:
                    # try keys like {"RGP": {...}}
                    if len(item) == 1 and isinstance(next(iter(item.values())), dict):
                        tag = str(next(iter(item.keys())))
                        obj = next(iter(item.values()))
                        links = obj.get("links", []) or []
                        cent = obj.get("centrality", float(len(links)))
                        entries.append({"tag": tag, "links": list(map(str, links)), "centrality": float(cent)})
                        continue
                    else:
                        continue
                links = item.get("links", []) or []
                cent = item.get("centrality", float(len(links)))
                entries.append({"tag": str(tag), "links": list(map(str, links)), "centrality": float(cent)})
        return entries

    else:
        raise ValueError("Unsupported tag index format in meta/tag_index.yml")

def build_graph(entries):
    tags = {e["tag"] for e in entries}
    # nodes with string IDs (tags) so your D3 .id(d => d.id) works naturally
    nodes = [{
        "id": e["tag"],
        "label": e["tag"],
        # Light normalization: keep centrality non-negative, scale down if huge
        "centrality": float(e.get("centrality", 0.0))
    } for e in entries]

    links = []
    for e in entries:
        for tgt in e.get("links", []):
            if tgt in tags:
                links.append({"source": e["tag"], "target": tgt})

    return {"nodes": nodes, "links": links}

def write_js(graph, out_path):
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    stamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    header = f"/* Auto-generated by generate_graph_data.py @ {stamp} | nodes={len(graph['nodes'])}, links={len(graph['links'])} */\n"
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(header)
        f.write("window.graph = ")
        f.write(json.dumps(graph, indent=2))
        f.write(";\n")

def main():
    try:
        entries = load_tag_index(TAG_INDEX_PATH)
    except Exception as e:
        print(f"❌ Failed to read/parse {TAG_INDEX_PATH}: {e}")
        sys.exit(1)

    graph = build_graph(entries)

    if not graph["nodes"]:
        print("❌ Zero nodes parsed from tag index — refusing to overwrite docs/graph_data.js.")
        sys.exit(2)

    write_js(graph, OUTPUT_PATH)
    print(f"✅ Graph data written to {OUTPUT_PATH} ({len(graph['nodes'])} nodes, {len(graph['links'])} links)")

if __name__ == "__main__":
    main()
