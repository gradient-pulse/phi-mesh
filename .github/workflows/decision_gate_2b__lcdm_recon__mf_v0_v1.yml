name: Decision gate 2B — ΛCDM recon control (MF V0+V1)

on:
  workflow_dispatch:
    inputs:
      recon_sims_url:
        description: "Release asset URL: tar.gz containing reconstructed sims in sims/<sim_id>/{dat_klm.fits,mf_klm.fits}"
        required: true
        default: "https://github.com/gradient-pulse/phi-mesh/releases/download/data-2026-02-15-planck-lensing-R3/lcdm_recon_sims__layout_sims.tar.gz"
      lmax:
        description: "Max multipole l to analyze"
        required: true
        default: "256"
      nside:
        description: "HEALPix nside for map-space topology"
        required: true
        default: "256"
      n_lcdm_sims:
        description: "How many reconstructed sims to process (require at least this many in bundle)"
        required: true
        default: "3"
      n_phase_sims:
        description: "Number of phase-randomized surrogates per sim (null draws)"
        required: true
        default: "2000"
      seed0:
        description: "Base RNG seed; sim i uses seed0+i"
        required: true
        default: "1400"
      n_nu:
        description: "Number of thresholds between nu_min and nu_max"
        required: true
        default: "61"
      nu_min:
        description: "Min threshold (in sigma units after standardization)"
        required: true
        default: "-3.0"
      nu_max:
        description: "Max threshold (in sigma units after standardization)"
        required: true
        default: "3.0"
      archive_prefix:
        description: "Filename prefix for outputs"
        required: true
        default: "lcdm_recon"
      strict_layout:
        description: "If true, require sims to be in sims/<sim_id>/{dat_klm.fits,mf_klm.fits}"
        required: true
        default: "true"

permissions:
  contents: write

concurrency:
  group: decision-gate-2b-lcdm-recon-mf-v0-v1
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 240

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install numpy scipy healpy

      - name: Download reconstructed ΛCDM sim products (tar.gz)
        run: |
          set -euo pipefail
          mkdir -p data/lcdm_recon_sims
          echo "Fetching: ${{ github.event.inputs.recon_sims_url }}"
          curl -L --retry 5 --retry-delay 5 --fail "${{ github.event.inputs.recon_sims_url }}" -o data/lcdm_recon_sims/recon_sims.tar.gz
          ls -lh data/lcdm_recon_sims

      - name: Extract sim bundle
        run: |
          set -euo pipefail
          mkdir -p data/lcdm_recon_sims/extracted
          tar -xzf data/lcdm_recon_sims/recon_sims.tar.gz -C data/lcdm_recon_sims/extracted
          echo "Top-level extracted:"
          ls -lah data/lcdm_recon_sims/extracted | sed -n '1,200p'
          echo "First 200 paths:"
          find data/lcdm_recon_sims/extracted -maxdepth 5 -type f | sed -n '1,200p'

      - name: Run Gate 2B (per-sim MF(V0,V1) + aggregate stats)
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, glob
          from pathlib import Path
          import numpy as np
          import subprocess

          RUN_ID = os.environ["GITHUB_RUN_ID"]
          LMAX = int("${{ github.event.inputs.lmax }}")
          NSIDE = int("${{ github.event.inputs.nside }}")
          N_LCDM_REQ = int("${{ github.event.inputs.n_lcdm_sims }}")
          N_PHASE = int("${{ github.event.inputs.n_phase_sims }}")
          SEED0 = int("${{ github.event.inputs.seed0 }}")
          N_NU = int("${{ github.event.inputs.n_nu }}")
          NU_MIN = float("${{ github.event.inputs.nu_min }}")
          NU_MAX = float("${{ github.event.inputs.nu_max }}")
          PREFIX = str("${{ github.event.inputs.archive_prefix }}").strip()
          STRICT = str("${{ github.event.inputs.strict_layout }}").lower() in ("true","1","yes","y")

          TOPO_SCRIPT = "experiments/rgpx_proof_proto/cmb_phase_dagger/cmb_topology_planck_lensing__mf_v0_v1.py"
          BASE = Path("data/lcdm_recon_sims/extracted")

          # --- Discover sim folders
          sim_pairs = []
          if STRICT:
            cand = sorted(glob.glob(str(BASE / "sims" / "*" / "dat_klm.fits")))
            for dat in cand:
              simdir = Path(dat).parent
              mf = simdir / "mf_klm.fits"
              if mf.exists():
                sim_pairs.append((simdir.name, str(simdir / "dat_klm.fits"), str(mf)))
          else:
            dats = sorted(glob.glob(str(BASE / "**/dat_klm.fits"), recursive=True))
            for dat in dats:
              simdir = Path(dat).parent
              mf = simdir / "mf_klm.fits"
              if mf.exists():
                sim_pairs.append((simdir.name, str(simdir / "dat_klm.fits"), str(mf)))

          discovered = len(sim_pairs)
          if discovered == 0:
            raise SystemExit("No sims discovered. Expected sims/<id>/{dat_klm.fits,mf_klm.fits} inside tarball.")

          # Fail fast if tarball doesn't contain requested number of sims
          if discovered < N_LCDM_REQ:
            raise SystemExit(
              f"Requested n_lcdm_sims={N_LCDM_REQ} but only discovered {discovered} sims in the tarball. "
              f"Repack/upload a bundle with >= {N_LCDM_REQ} sims (or lower the input)."
            )

          sim_pairs = sim_pairs[:N_LCDM_REQ]

          out_dir = Path("results/cmb_topology_mf_v0_v1")
          out_dir.mkdir(parents=True, exist_ok=True)

          per_sim = []
          D0s, D1s, Dmfs = [], [], []

          recon_url = os.environ.get("RECON_URL", "")

          for i, (sim_id, dat_path, mf_path) in enumerate(sim_pairs):
            seed = SEED0 + i
            out_json = out_dir / f"{PREFIX}__mf_v0_v1__sim{i:03d}__{sim_id}__lmax{LMAX}__nside{NSIDE}__phasesims{N_PHASE}__seed{seed}__run{RUN_ID}.json"

            cmd = [
              "python", TOPO_SCRIPT,
              "--dat_klm", dat_path,
              "--mf_klm",  mf_path,
              "--lmax", str(LMAX),
              "--nside", str(NSIDE),
              "--n_sims", str(N_PHASE),
              "--seed", str(seed),
              "--n_nu", str(N_NU),
              "--nu_min", str(NU_MIN),
              "--nu_max", str(NU_MAX),
              "--dat_url", f"LCDM_RECON_SIM_TARBALL:{recon_url}",
              "--mf_url",  f"LCDM_RECON_SIM_TARBALL:{recon_url}",
              "--out", str(out_json),
            ]

            subprocess.run(cmd, check=True)

            with open(out_json, "r", encoding="utf-8") as f:
              jj = json.load(f)

            D0 = float(jj["observed"]["D0_L2"])
            D1 = float(jj["observed"]["D1_L2"])
            Dmf = float(jj["observed"]["D_mf"])

            D0s.append(D0); D1s.append(D1); Dmfs.append(Dmf)

            per_sim.append({
              "sim": i,
              "sim_id": sim_id,
              "seed": seed,
              "D0_L2": D0,
              "D1_L2": D1,
              "D_mf": Dmf,
              "out_json": str(out_json),
              "dat_klm": dat_path,
              "mf_klm": mf_path,
            })

            print(f"[sim {i:03d}] sim_id={sim_id} D0={D0:.6e} D1={D1:.6e} Dmf={Dmf:.6e}")

          D0s = np.array(D0s, dtype=float)
          D1s = np.array(D1s, dtype=float)
          Dmfs = np.array(Dmfs, dtype=float)

          summary = {
            "kind": "decision_gate_lcdm_recon_mf_v0_v1",
            "run_id": int(RUN_ID),
            "inputs": {
              "lmax": LMAX,
              "nside": NSIDE,
              "n_lcdm_sims_requested": N_LCDM_REQ,
              "n_lcdm_sims_discovered": discovered,
              "n_lcdm_sims_used": len(per_sim),
              "n_phase_sims": N_PHASE,
              "seed0": SEED0,
              "n_nu": N_NU,
              "nu_min": NU_MIN,
              "nu_max": NU_MAX,
              "strict_layout": STRICT,
              "recon_sims_url": recon_url,
            },
            "D_stats": {
              "D0_mean": float(D0s.mean()),
              "D0_std": float(D0s.std(ddof=0)),
              "D0_min": float(D0s.min()),
              "D0_max": float(D0s.max()),
              "D1_mean": float(D1s.mean()),
              "D1_std": float(D1s.std(ddof=0)),
              "D1_min": float(D1s.min()),
              "D1_max": float(D1s.max()),
              "D_mf_mean": float(Dmfs.mean()),
              "D_mf_std": float(Dmfs.std(ddof=0)),
              "D_mf_min": float(Dmfs.min()),
              "D_mf_max": float(Dmfs.max()),
            },
            "per_sim": per_sim,
          }

          summary_path = out_dir / f"{PREFIX}__mf_v0_v1__aggregate__lmax{LMAX}__nside{NSIDE}__nsims{len(per_sim)}__phasesims{N_PHASE}__seed{SEED0}__run{RUN_ID}.json"
          with open(summary_path, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)

          print("Wrote aggregate:", summary_path)
          PY
        env:
          RECON_URL: ${{ github.event.inputs.recon_sims_url }}

      - name: Upload result artifact
        uses: actions/upload-artifact@v4
        with:
          name: gate2b_lcdm_recon_mf_v0_v1__lmax${{ github.event.inputs.lmax }}__nside${{ github.event.inputs.nside }}__nsims${{ github.event.inputs.n_lcdm_sims }}__phasesims${{ github.event.inputs.n_phase_sims }}__run${{ github.run_id }}
          path: results/cmb_topology_mf_v0_v1/*.json
          retention-days: 90

      - name: Archive Gate 2B results into repo (control suite)
        run: |
          set -euo pipefail

          BASE_DIR="experiments/rgpx_proof_proto/cmb_phase_dagger/results/topology_mf_v0_v1"
          RUN_DIR="${BASE_DIR}/controls/lcdm_recon/runs/${{ github.run_id }}"
          mkdir -p "$RUN_DIR"

          cp -v results/cmb_topology_mf_v0_v1/*.json "$RUN_DIR/"

          # Record discovered/used counts in a reproducible way
          DISCOVERED="$(find data/lcdm_recon_sims/extracted/sims -maxdepth 2 -type f -name dat_klm.fits | wc -l | tr -d ' ')"
          USED="$(ls -1 results/cmb_topology_mf_v0_v1/*__sim*.json 2>/dev/null | wc -l | tr -d ' ')"

          cat > "${RUN_DIR}/manifest.txt" <<EOF
          run_id: ${{ github.run_id }}
          workflow: ${{ github.workflow }}
          ref: ${{ github.ref }}
          sha: ${{ github.sha }}
          control: lcdm_recon_sims_plus_phase_random_null__mf_v0_v1
          lmax: ${{ github.event.inputs.lmax }}
          nside: ${{ github.event.inputs.nside }}
          n_lcdm_sims_requested: ${{ github.event.inputs.n_lcdm_sims }}
          n_lcdm_sims_discovered: ${DISCOVERED}
          n_lcdm_sims_used: ${USED}
          n_phase_sims: ${{ github.event.inputs.n_phase_sims }}
          seed0: ${{ github.event.inputs.seed0 }}
          recon_sims_url: ${{ github.event.inputs.recon_sims_url }}
          strict_layout: ${{ github.event.inputs.strict_layout }}
          EOF

          ls -lh "$RUN_DIR"

      - name: Commit archived Gate 2B result (if changed) and push safely
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add experiments/rgpx_proof_proto/cmb_phase_dagger/results/topology_mf_v0_v1/controls/lcdm_recon/runs/${{ github.run_id }}/

          if git diff --cached --quiet; then
            echo "No new Gate 2B files to commit."
            exit 0
          fi

          git commit -m "Decision gate 2B: ΛCDM recon control (MF V0+V1) (run ${{ github.run_id }})"

          for i in 1 2 3; do
            git fetch origin main
            git rebase origin/main || (git rebase --abort && exit 1)

            if git push; then
              echo "Push succeeded."
              exit 0
            fi

            echo "Push failed (attempt $i). Retrying after short delay..."
            sleep 3
          done

          echo "Push failed after retries."
          exit 1
