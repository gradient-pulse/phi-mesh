<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Phi-Mesh Tag Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0b0f;
      --fg: #f5f7fb;
      --muted: #9aa4b2;
      --accent: #7dd3fc;
      --panel: rgba(255,255,255,0.06);
      --chip: rgba(125,211,252,0.14);
      --border: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    header { padding: 14px 18px 8px; border-bottom: 1px solid var(--border); }
    .title-row { display:flex; align-items:center; gap:12px; }
    h1 { margin:0; font-size:18px; font-weight:600; letter-spacing:.2px; }
    .search-wrap { margin-top:10px; }
    #tagSearch {
      width: 100%;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--fg);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }

    main { display: grid; grid-template-columns: 1fr 360px; height: calc(100% - 70px); }
    .graphPane { position: relative; }
    .graphPane .hint {
      position:absolute; left:12px; bottom:12px; color: var(--muted); font-size:12px;
      background: rgba(0,0,0,0.35); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06);
      user-select:none; pointer-events:none;
    }

    aside { border-left: 1px solid var(--border); overflow-y: auto; }
    .details { padding: 16px 18px; }
    .details h2 { margin:0 0 8px 0; font-size:18px; }
    .chips { display:flex; gap:8px; flex-wrap:wrap; margin: 8px 0 0; }
    .chip { font-size:12px; padding:6px 8px; border-radius: 999px; background: var(--chip); border: 1px solid rgba(125,211,252,0.25); color: var(--fg); }
    .callout {
      margin-top: 12px; padding: 10px 12px; border-radius: 12px; background: var(--panel);
      border: 1px solid var(--border); color: var(--fg); font-size: 13px; line-height: 1.45;
    }
    .links { margin-top: 12px; }
    .links h4 { margin: 10px 0 6px 0; font-size: 13px; color: var(--muted); font-weight:600; letter-spacing:.2px; }
    .links a {
      display:block; text-decoration:none; color: var(--accent);
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
      padding: 6px 8px; border-radius: 8px; background: rgba(125,211,252,0.08);
      border: 1px solid rgba(125,211,252,0.16); margin-bottom:6px;
    }
    .links a:hover { text-decoration: underline; }

    /* D3 Graph */
    svg { width: 100%; height: 100%; display: block; background: transparent; }
    .link { stroke: #9aa4b280; stroke-width: 1; }
    .node circle {
      fill: #00BFFF; fill-opacity: 0.9;
      stroke: #fff; stroke-opacity: 0.75; stroke-width: 1px;
    }
    .node text.label {
      fill: #eaf6ff; font-size: 12px; pointer-events: none; user-select: none;
      paint-order: stroke; stroke: rgba(0,0,0,0.55); stroke-width: 3px;
    }
    .node.dim circle { opacity: 0.15; }
    .node.dim text.label { opacity: 0.1; }
    .link.dim { opacity: 0.08; }
    .node.highlight circle { fill: #38bdf8; }
    .node.neighbor circle { fill: #60a5fa; }

    .empty { color: var(--muted); padding: 32px 18px; }
  </style>
</head>
<body>
  <header>
    <div class="title-row">
      <h1>Phi-Mesh Tag Browser</h1>
    </div>
    <div class="search-wrap">
      <input id="tagSearch" type="search" placeholder="Search tags (prefix match). ESC to clear. Pan/zoom with mouse." />
    </div>
  </header>

  <main>
    <div class="graphPane">
      <svg id="graph"></svg>
      <div class="hint">Tip: click a node to focus. Double-click empty space to reset view.</div>
    </div>
    <aside>
      <div id="details" class="details empty">Pick a tag to see details.</div>
    </aside>
  </main>

  <!-- Data blob produced by generate_graph_data.py -->
  <script src="data.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // ---- Data in: expect window.PHI_DATA = { nodes, links, tagResources, callouts? } ----
    const DATA = (window.PHI_DATA) ? window.PHI_DATA : {nodes:[],links:[],tagResources:{},callouts:{}};
    const nodes = DATA.nodes?.map(d => ({...d})) ?? [];
    const links = DATA.links?.map(l => ({...l})) ?? [];
    const tagResources = DATA.tagResources || {};
    const callouts = DATA.callouts || {};

    // degree map for sizing/collide
    const degree = {};
    links.forEach(({source, target}) => {
      degree[source] = (degree[source] || 0) + 1;
      degree[target] = (degree[target] || 0) + 1;
    });

    // neighbor lookup
    const nbr = new Map();
    nodes.forEach(n => nbr.set(n.id, new Set()));
    links.forEach(({source, target}) => { nbr.get(source).add(target); nbr.get(target).add(source); });

    const svg = d3.select("#graph");
    const width = svg.node().clientWidth;
    const height = svg.node().clientHeight;

    // zoom/pan
    const gRoot = svg.append("g");
    const gLinks = gRoot.append("g").attr("class", "links");
    const gNodes = gRoot.append("g").attr("class", "nodes");

    svg.call(d3.zoom()
      .scaleExtent([0.25, 4])
      .on("zoom", (event) => gRoot.attr("transform", event.transform)));

    svg.on("dblclick.zoomReset", () => {
      svg.transition().duration(350).call(d3.zoom().transform, d3.zoomIdentity);
      clearDim();
      selectedId = null;
      updateDetails(null);
    });

    // line elements
    const linkSel = gLinks.selectAll("line")
      .data(links)
      .join("line")
      .attr("class", "link");

    // node groups (circle + label stay attached)
    const nodeSel = gNodes.selectAll("g.node")
      .data(nodes, d => d.id)
      .join(enter => {
        const g = enter.append("g").attr("class", "node").style("cursor", "pointer");
        g.append("circle")
          .attr("r", d => 6 + Math.sqrt(Math.max(1, degree[d.id] || 1)))
          .on("click", (_, d) => onNodeClick(d));
        g.append("text")
          .attr("class", "label")
          .attr("dy", 16) // sits under node
          .text(d => d.id);
        return g;
      });

    // simulation with a bit more breathing room
    const sim = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links)
        .id(d=>d.id)
        .distance(115)
        .strength(0.35))
      .force('charge', d3.forceManyBody().strength(-230))
      .force('collide', d3.forceCollide(d => 10 + Math.sqrt(Math.max(1, degree[d.id] || 1))))
      .force('center', d3.forceCenter(width/2, height/2))
      .on('tick', ticked);

    function ticked(){
      linkSel
        .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);

      nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
    }

    let selectedId = null;

    function dimAll(exceptId=null){
      nodeSel.classed("dim", d => d.id !== exceptId && !(nbr.get(exceptId)?.has(d.id)));
      linkSel.classed("dim", l => !(l.source.id === exceptId || l.target.id === exceptId));
      nodeSel.classed("highlight", d => d.id === exceptId);
      nodeSel.classed("neighbor", d => nbr.get(exceptId)?.has(d.id) || false);
    }
    function clearDim(){
      nodeSel.classed("dim", false).classed("highlight", false).classed("neighbor", false);
      linkSel.classed("dim", false);
    }

    function centerOnNode(n){
      const t = d3.zoomTransform(svg.node());
      const scale = t.k || 1;
      const tx = width/2 - (n.x * scale);
      const ty = height/2 - (n.y * scale);
      svg.transition().duration(400)
        .call(d3.zoom().transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
    }

    function onNodeClick(n){
      selectedId = n.id;
      dimAll(selectedId);
      centerOnNode(n);
      updateDetails(selectedId);
    }

    // ---- Sidebar details (clickable Papers/Podcasts + callout) ----
    const detailsEl = document.getElementById('details');

    function topN(arr, n){ return (arr || []).slice(0, n); }

    function updateDetails(tagId){
      if (!tagId) {
        detailsEl.className = 'details empty';
        detailsEl.textContent = 'Pick a tag to see details.';
        return;
      }
      const deg = degree[tagId] || 0;
      const cent = (nodes.find(x => x.id === tagId)?.centrality ?? 0);

      const res = tagResources[tagId] || { papers:[], podcasts:[] };
      const papers = topN(res.papers, 3);
      const pods = topN(res.podcasts, 3);
      const blurb = callouts[tagId];

      let html = `<h2>${tagId}</h2>`;
      html += `<div class="chips"><span class="chip">degree: ${deg}</span><span class="chip">centrality: ${cent.toFixed(2)}</span></div>`;

      if (blurb) {
        html += `<div class="callout">${escapeHTML(blurb)}</div>`;
      }

      if (papers.length || pods.length){
        html += `<div class="links">`;
        if (papers.length){
          html += `<h4>Papers</h4>` + papers.map(u => `<a class="paper" href="${u}" target="_blank" rel="noopener noreferrer" title="${u}">${u}</a>`).join("");
        }
        if (pods.length){
          html += `<h4>Podcasts</h4>` + pods.map(u => `<a class="podcast" href="${u}" target="_blank" rel="noopener noreferrer" title="${u}">${u}</a>`).join("");
        }
        html += `</div>`;
      }

      detailsEl.className = 'details';
      detailsEl.innerHTML = html;
    }

    function escapeHTML(s){
      return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    // ---- Search (prefix, filters the graph; sidebar stays as details) ----
    const searchEl = document.getElementById('tagSearch');

    function applySearchFilter(prefixRaw){
      const q = (prefixRaw || "").trim().toLowerCase();
      if (!q){
        clearDim();
        // make sure everything visible again
        nodeSel.style("display", null);
        linkSel.style("display", null);
        return;
      }
      const match = new Set(nodes.filter(n => n.id.toLowerCase().startsWith(q)).map(n => n.id));
      // show only matched nodes (and hide others completely)
      nodeSel.style("display", d => match.has(d.id) ? null : "none");
      // hide links that don't connect two visible nodes
      linkSel.style("display", l => (match.has(l.source.id) && match.has(l.target.id)) ? null : "none");
    }

    searchEl.addEventListener('input', (e) => {
      applySearchFilter(e.target.value);
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchEl.value = '';
        applySearchFilter('');
        e.preventDefault();
      }
    });
  </script>
</body>
</html>
