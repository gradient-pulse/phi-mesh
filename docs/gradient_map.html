<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Pulse Echo)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:12px;left:12px;display:flex;gap:8px;align-items:center;background:#0f141b;border:1px solid #223;padding:8px 10px;border-radius:10px;z-index:10}
  button,select{background:#131a22;border:1px solid #2a3442;color:#e6edf3;border-radius:8px;padding:6px 10px;cursor:pointer}
  #legend{opacity:.7;font-size:12px}
  canvas{display:block;width:100%;height:100%}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>0.5</option><option selected>1.0</option><option>1.5</option><option>2.0</option>
    </select>
  </label>
  <span id="legend">URL knobs: <code>?hop=0.75&half=2.0&spacing=6&autoplay=1</code></span>
</div>

<canvas id="c"></canvas>

<!-- 1) the big blob -->
<script src="data.js"></script>
<!-- 2) the 1-line alias to publish window.GRAPH_DATA -->
<script src="phi_data_alias.js"></script>

<script>
(async function(){
  // --- URL knobs ---
  const q=new URLSearchParams(location.search);
  const HOP  = +q.get('hop')     || 0.75;   // per-hop decay
  const HALF = +q.get('half')    || 2.0;    // seconds half-life
  const PACE = +q.get('spacing') || 6.0;    // seconds between events
  const AUTOPLAY = q.get('autoplay')==='1';

  // --- resolve graph from window (thanks to alias shim) ---
  const G = (window.GRAPH_DATA || window.PHI_DATA || window.DATA || window.data || window.GRAPH);
  if (!G || !Array.isArray(G.nodes) || !Array.isArray(G.links)) {
    console.error('No graph found. window.GRAPH_DATA is missing or malformed.');
    return;
  }

  // --- load event echoes (hand-made) ---
  const E = await fetch('./echoes.json').then(r=>r.json()).catch(()=>({events:[]}));

  // --- index graph ---
  const idx=new Map(G.nodes.map((n,i)=>[n.id,i]));
  const N=G.nodes.length;
  const pos = G.nodes.map(n => ({ x:(n.x ?? n.fx ?? n.nx ?? 0), y:(n.y ?? n.fy ?? n.ny ?? 0) }));
  const adj=Array.from({length:N},()=>[]);
  for(const e of G.links){
    const a=idx.get(typeof e.source==='object'?e.source.id:e.source);
    const b=idx.get(typeof e.target==='object'?e.target.id:e.target);
    if(a!=null && b!=null){ adj[a].push({j:b}); adj[b].push({j:a}); }
  }

  // BFS once per source
  function hopsFrom(src){
    const inf=1e9, d=Array(N).fill(inf); d[src]=0; const q=[src];
    while(q.length){ const i=q.shift(); for(const {j} of adj[i]) if(d[j]===inf){ d[j]=d[i]+1; q.push(j); } }
    return d;
  }

  // --- canvas ---
  const C=document.getElementById('c'), X=C.getContext('2d');
  function fit(){ C.width=innerWidth*devicePixelRatio; C.height=innerHeight*devicePixelRatio; X.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
  addEventListener('resize',fit,{passive:true}); fit();

  // normalize positions to canvas
  const [minX,maxX]=[Math.min(...pos.map(p=>p.x)), Math.max(...pos.map(p=>p.x))];
  const [minY,maxY]=[Math.min(...pos.map(p=>p.y)), Math.max(...pos.map(p=>p.y))];
  const dx=(maxX-minX)||1, dy=(maxY-minY)||1;
  const tx=p=>({ x:(p.x-minX)/dx * C.width/devicePixelRatio,
                 y:(p.y-minY)/dy * C.height/devicePixelRatio });

  // --- echo engine ---
  const TAU = HALF/Math.log(2);
  const events = (E.events||[]).map((ev,k)=>({
    ...ev,
    t: k*(PACE),
    source: idx.get(ev.source_tag),
    hops: null
  })).filter(ev=>ev.source!=null);
  for(const ev of events){ ev.hops = hopsFrom(ev.source); }

  let t=0, playing=AUTOPLAY;
  const speedSel=document.getElementById('speed');
  document.getElementById('play').onclick=()=>playing=true;
  document.getElementById('pause').onclick=()=>playing=false;
  const now=()=>performance.now()/1000; let last=now();

  window.__ECHO_TIMESERIES__=[];

  function frame(){
    const n=now(), dt=Math.min(0.05,n-last); last=n; if(playing) t+=dt*(+speedSel.value);
    const I=new Float32Array(N);
    for(const ev of events){
      const age=Math.max(0,t-ev.t); const timeDecay=Math.exp(-age/TAU);
      for(let i=0;i<N;i++){
        const h=ev.hops[i];
        if(!isFinite(h) || h>(ev.max_hops??4)) continue;
        I[i]+= (ev.amplitude??1) * timeDecay * Math.pow(HOP,h);
      }
    }
    // draw
    X.clearRect(0,0,C.width,C.height);
    X.globalAlpha=0.08; X.lineWidth=1;
    for(const e of G.links){
      const a=idx.get(typeof e.source==='object'?e.source.id:e.source);
      const b=idx.get(typeof e.target==='object'?e.target.id:e.target);
      if(a==null||b==null) continue;
      const A=tx(pos[a]), B=tx(pos[b]);
      X.beginPath(); X.moveTo(A.x,A.y); X.lineTo(B.x,B.y); X.strokeStyle="#7aa2f7"; X.stroke();
    }
    for(let i=0;i<N;i++){
      const p=tx(pos[i]); const r=2 + 10*Math.min(1,I[i]);
      X.beginPath(); X.arc(p.x,p.y,r,0,Math.PI*2);
      X.fillStyle=`rgba(180,220,255,${0.25+Math.min(0.75,I[i])})`; X.fill();
    }
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
