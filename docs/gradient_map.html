<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Tag Pulses)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:12px;left:12px;display:flex;gap:8px;align-items:center;background:#0f141b;border:1px solid #223;padding:8px 10px;border-radius:10px;z-index:10}
  button,select{background:#131a22;border:1px solid #2a3442;color:#e6edf3;border-radius:8px;padding:6px 10px;cursor:pointer}
  #legend{opacity:.7;font-size:12px}
  canvas{display:block;width:100%;height:100%}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>0.5</option><option selected>1.0</option><option>1.5</option><option>2.0</option>
    </select>
  </label>
  <span id="legend">URL: <code>?half=3&spacing=5&autoplay=1</code> • fires follow pulse dates</span>
</div>
<canvas id="c"></canvas>

<script>
(async function(){
  // -------- URL knobs --------
  const q = new URLSearchParams(location.search);
  const HALF = +q.get('half')    || 3.0;  // seconds half-life (τ = HALF/ln2)
  const GAP  = +q.get('spacing') || 5.0;  // seconds between consecutive pulse events
  const AUTOPLAY = q.get('autoplay') === '1';
  const TAU = HALF / Math.log(2);

  // -------- Pull graph directly from Tag Map data --------
  // Tag Map exposes `window.PHI_DATA = { nodes:[{id,x,y,centrality…}], links:[{source,target}], pulsesByTag:{tag:[{title,date,…}]}, … }`
  const D = (window.PHI_DATA && typeof window.PHI_DATA==='object') ? window.PHI_DATA : null;
  if(!D || !Array.isArray(D.nodes) || !Array.isArray(D.links)){
    console.error('PHI_DATA missing; open tag_map.html first or ensure docs/data.js defines window.PHI_DATA.');
    return;
  }

  // Index + positions (already in screen coords for Tag Map; normalize to [0,1] here)
  const idx = new Map(D.nodes.map((n,i)=>[n.id,i]));
  let pos = D.nodes.map(n => ({x:(n.x ?? 0), y:(n.y ?? 0)}));
  const minX=Math.min(...pos.map(p=>p.x)), maxX=Math.max(...pos.map(p=>p.x));
  const minY=Math.min(...pos.map(p=>p.y)), maxY=Math.max(...pos.map(p=>p.y));
  const dx=(maxX-minX)||1, dy=(maxY-minY)||1;
  pos = pos.map(p => ({x:(p.x-minX)/dx, y:(p.y-minY)/dy}));

  // Resolve links to indices
  const links = D.links.map(l => {
    const a = idx.get(typeof l.source==='object' ? l.source.id : l.source);
    const b = idx.get(typeof l.target==='object' ? l.target.id : l.target);
    return (a!=null && b!=null) ? {a,b} : null;
  }).filter(Boolean);

  // -------- Build time-ordered “fires” from pulse dates --------
  // Flatten pulsesByTag into [{tag, date: 'YYYY-MM-DD'}], sort by date, assign times t=k*GAP.
  function parseDate(s){
    // allow 'YYYY-MM-DD' or 'YYYY-MM-DD_…'
    if(!s) return null;
    const m = String(s).match(/^(\d{4})-(\d{2})-(\d{2})/);
    if(!m) return null;
    return new Date(+m[1], +m[2]-1, +m[3]);
  }

  const rawEvents = [];
  if (D.pulsesByTag && typeof D.pulsesByTag==='object'){
    for (const [tag, arr] of Object.entries(D.pulsesByTag)){
      if(!Array.isArray(arr)) continue;
      for (const p of arr){
        const dt = parseDate(p && p.date);
        if (dt && idx.has(tag)) rawEvents.push({tag, date: dt});
      }
    }
  }

  rawEvents.sort((a,b)=>a.date - b.date);
  const events = rawEvents.map((ev,k)=>({
    tag: ev.tag,
    node: idx.get(ev.tag),
    t: k * GAP
  }));

  // If there are no dated pulses, provide a gentle default (walk through top centrality tags)
  if (!events.length){
    const top = [...D.nodes]
      .map((n,i)=>({i, c: (typeof n.centrality==='number'? n.centrality : 0)}))
      .sort((a,b)=>b.c-a.c)
      .slice(0,24);
    top.forEach((o,k)=>events.push({tag:D.nodes[o.i].id, node:o.i, t:k*GAP}));
  }

  // -------- Canvas plumbing --------
  const C = document.getElementById('c'), X = C.getContext('2d');
  function fit(){ C.width=innerWidth*devicePixelRatio; C.height=innerHeight*devicePixelRatio; X.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
  addEventListener('resize',fit,{passive:true}); fit();

  const M = 0.05; // margin
  const tx = p => ({
    x: (M + (1-2*M)*p.x) * C.width  / devicePixelRatio,
    y: (M + (1-2*M)*p.y) * C.height / devicePixelRatio
  });

  // -------- Playback state --------
  let t=0, playing=AUTOPLAY;
  const speedSel = document.getElementById('speed');
  document.getElementById('play').onclick  = () => (playing=true);
  document.getElementById('pause').onclick = () => (playing=false);
  function now(){ return performance.now()/1000 }
  let last = now();

  // Precompute for node-centric access: eventsByNode[i] = [t0,t1,...]
  const fires = Array.from({length:D.nodes.length}, ()=>[]);
  for (const ev of events){ if (ev.node!=null) fires[ev.node].push(ev.t); }

  // -------- Draw loop --------
  function nodeIntensity(i, time){
    // Sum decays from all fires of node i
    let s = 0;
    const ts = fires[i];
    // walk last few only (performance)
    for (let k=ts.length-1; k>=0; k--){
      const age = time - ts[k]; if (age < 0) continue;
      const w = Math.exp(-age/TAU);
      if (w < 1e-3) break;
      s += w;
    }
    return s;
  }

  function frame(){
    const n = now(), dt = Math.min(0.05, n-last); last = n;
    if (playing) t += dt * (+speedSel.value);

    // Compute intensities
    const I = new Float32Array(D.nodes.length);
    for (let i=0;i<I.length;i++) I[i] = nodeIntensity(i, t);

    // Draw
    X.clearRect(0,0,C.width,C.height);

    // Links glow when both ends are active (product)
    X.lineWidth = 1.2;
    for (const {a,b} of links){
      const A = tx(pos[a]), B = tx(pos[b]);
      const glow = Math.min(1, I[a]*I[b]);
      X.strokeStyle = `rgba(122,162,247,${0.06 + 0.34*glow})`;
      X.beginPath(); X.moveTo(A.x,A.y); X.lineTo(B.x,B.y); X.stroke();
    }

    // Nodes: base dot + intensity halo
    for (let i=0;i<D.nodes.length;i++){
      const p = tx(pos[i]);
      const j = Math.min(1, I[i]);
      const r = 4 + 12*j;

      // halo
      if (j>0){
        const g = X.createRadialGradient(p.x,p.y, r*0.4, p.x,p.y, r);
        g.addColorStop(0, `rgba(145,200,255,${0.20*j})`);
        g.addColorStop(1, `rgba(145,200,255,0)`);
        X.fillStyle = g;
        X.beginPath(); X.arc(p.x,p.y,r,0,Math.PI*2); X.fill();
      }
      // core
      X.fillStyle = `rgba(200,230,255,${0.45 + 0.5*j})`;
      X.beginPath(); X.arc(p.x,p.y, 2.5 + 2*j, 0, Math.PI*2); X.fill();
    }

    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
