<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Pulse-by-Pulse on Tag Map)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0b0c10; --panel:#0f141b; --fg:#e6edf3; --muted:#9aa7ba;
    --link:#b9c7dd; --lit:#9dd1ff; --glow:#cfe8ff; --pulse:#ff8a70;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:12px;left:12px;display:flex;gap:10px;align-items:center;background:var(--panel);
      border:1px solid rgba(255,255,255,.06); padding:8px 10px;border-radius:10px; z-index:10}
  button,select{background:#131a22;border:1px solid #2a3442;color:var(--fg);border-radius:8px;padding:6px 10px;cursor:pointer}
  #legend{opacity:.75;font-size:12px}
  #ticker{position:fixed;top:12px;right:12px;background:var(--panel);border:1px solid rgba(255,255,255,.06);
          padding:8px 12px;border-radius:12px;font-size:13px;opacity:.95; z-index:10}
  svg{display:block;width:100%;height:100%}
  .link{stroke:var(--link);stroke-opacity:.08}
  .link.lit{stroke-opacity:.35}
  .node ellipse{fill:#74b7ff; opacity:.22}
  .node.lit ellipse{fill:var(--lit); opacity:1}
  .node .glow{filter:blur(6px);opacity:.0;pointer-events:none}
  .node.lit .glow{opacity:.5}
  .node text{display:none; font-size:12px; fill:var(--muted); pointer-events:none}
  .node.lit text{display:block}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>0.5</option><option selected>1.0</option><option>1.5</option><option>2.0</option>
    </select>
  </label>
  <span id="legend">URL: <code>?half=3&spacing=6&autoplay=1</code></span>
</div>
<div id="ticker">—</div>

<svg id="graph" role="img" aria-label="Gradient Map (Pulse)"></svg>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="data.js"></script>
<script>
(async function(){
  // ---------------- URL knobs ----------------
  const Q = new URLSearchParams(location.search);
  const HALF     = +Q.get('half')     || 3;   // seconds half-life for lit intensity
  const SPACING  = +Q.get('spacing')  || 6;   // seconds between pulses
  const AUTOPLAY = Q.get('autoplay')==='1';

  const ticker = document.getElementById('ticker');
  const speedSel = document.getElementById('speed');
  const playBtn  = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');

  // ---------------- Data ----------------
  // Expect window.PHI_DATA (same as tag_map)
  const DATA = (window.PHI_DATA && typeof window.PHI_DATA==='object') ? window.PHI_DATA : {nodes:[],links:[],pulsesByTag:{}};

  // Build a unique, dated pulse list from pulsesByTag
  // Each entry like {id,title,date,tags:Set([...])}
  const byKey = new Map();
  for(const [tag,arr] of Object.entries(DATA.pulsesByTag||{})){
    for(const p of (arr||[])){
      const key = (p.id || `${p.title||''}__${p.date||''}` || Math.random().toString(36));
      if(!byKey.has(key)){
        byKey.set(key, { id:key, title:p.title||'Pulse', date:p.date||'', tags:new Set() });
      }
      byKey.get(key).tags.add(tag);
    }
  }
  const pulses = [...byKey.values()].sort((a,b)=> String(a.date).localeCompare(String(b.date)));
  if(!pulses.length){
    ticker.textContent = 'No pulses found in PHI_DATA.pulsesByTag';
  }

  // ---------------- SVG & Layers ----------------
  const svg = d3.select('#graph');
  const W   = (svg.node().clientWidth || 1200);
  const H   = (svg.node().clientHeight|| 800);
  svg.attr('viewBox', `0 0 ${W} ${H}`).attr('preserveAspectRatio','xMidYMin meet');

  const root = svg.append('g');
  const linkLayer = root.append('g').attr('class','links');
  const nodeLayer = root.append('g').attr('class','nodes');

  // Map id->node object; rebuild links with node refs
  const idToNode = new Map(DATA.nodes.map(n=>[n.id,n]));
  const links = (DATA.links||[]).map(l=>({
    source:idToNode.get(l.source)||l.source,
    target:idToNode.get(l.target)||l.target
  })).filter(l=>l.source && l.target);

  // ---- sizing (copied from tag_map style) ----
  const degree = new Map();
  for(const l of links){
    degree.set(l.source.id,(degree.get(l.source.id)||0)+1);
    degree.set(l.target.id,(degree.get(l.target.id)||0)+1);
  }
  function nodeScore(d){
    const c = d && d.centrality;
    return (typeof c === 'number') ? c : (degree.get(d.id)||1);
  }
  const centralities = DATA.nodes.map(nodeScore);
  const mmMin = d3.min(centralities), mmMax = d3.max(centralities);
  const cMin = (mmMin==null?0:mmMin), cMax=(mmMax==null?1:mmMax);
  const rScale = d3.scaleSqrt()
    .domain([ (cMin===0?0.0001:cMin), (cMax===0?1:cMax) ])
    .range([5, 20]);
  const ellipseAspect = 1.6;

  // ---- Force simulation (same spirit as tag_map) ----
  const sim = d3.forceSimulation(DATA.nodes)
    .force('link', d3.forceLink(links).id(d=>d.id).distance(100).strength(0.40))
    .force('charge', d3.forceManyBody().strength(-320))
    .force('center', d3.forceCenter(W/2, H/2))
    .force('collide', d3.forceCollide().radius(d=>rScale(nodeScore(d))*1.5));

  // ---- draw static nodes/links once; update classes each tick/pulse ----
  const linkSel = linkLayer.selectAll('line').data(links).join('line').attr('class','link');

  const nodeSel = nodeLayer.selectAll('g.node')
    .data(DATA.nodes, d=>d.id)
    .join(enter=>{
      const g = enter.append('g').attr('class','node');
      // soft glow
      g.append('circle')
        .attr('class','glow')
        .attr('r', d=>rScale(nodeScore(d))*1.6)
        .attr('fill','var(--glow)');
      // ellipse body
      g.append('ellipse')
        .attr('rx', d=>rScale(nodeScore(d))*ellipseAspect)
        .attr('ry', d=>rScale(nodeScore(d)));
      // label (anchored just below ellipse)
      g.append('text')
        .attr('text-anchor','middle')
        .attr('x',0)
        .attr('y', d=>rScale(nodeScore(d)) + 12)
        .text(d=>d.id);
      return g;
    });

  sim.on('tick', ()=>{
    linkSel
      .attr('x1', d=>d.source.x).attr('y1', d=>d.source.y)
      .attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
    nodeSel.attr('transform', d=>`translate(${d.x},${d.y})`);
  });

  // ---------------- Pulse engine ----------------
  const TAU = HALF/Math.log(2); // half-life in seconds → decay const
  let t = 0, last = performance.now()/1000, playing = AUTOPLAY;
  playBtn.onclick = ()=> playing = true;
  pauseBtn.onclick= ()=> playing = false;

  // active set & fade buffer
  const intensity = new Map(DATA.nodes.map(n=>[n.id, 0])); // decays over time

  // utility: update lit classes based on current pulse + decay
  function renderState(activeTags){
    // decay
    const now = performance.now()/1000;
    const dt  = Math.min(0.05, now-last);
    last = now;
    for(const [id,val] of intensity){
      const decayed = val * Math.exp(-dt/TAU);
      intensity.set(id, decayed);
    }
    // inject current pulse tags to full intensity
    if(activeTags){
      for(const tag of activeTags) intensity.set(tag, 1.0);
    }
    // classify nodes
    nodeSel.classed('lit', d => (intensity.get(d.id)||0) > 0.12);
    // show only links where both ends are lit (cluster pop)
    linkSel.classed('lit', d => (nodeSel.filter(n => n===d.source).classed('lit') &&
                                 nodeSel.filter(n => n===d.target).classed('lit')))
           .style('display', d => (nodeSel.filter(n => n===d.source).classed('lit') &&
                                   nodeSel.filter(n => n===d.target).classed('lit')) ? null : 'none');
  }

  // Build per-frame loop that steps pulses every SPACING seconds
  let k = 0; // pulse index
  function stepPulse(){
    if(!pulses.length) return;
    const p = pulses[k % pulses.length];
    ticker.textContent = `${p.title} — ${p.date || '—'}`;
    renderState(p.tags);
    if(playing){
      t += (+speedSel.value) * 0.016; // approx per-call increment
      // switch pulse when its window elapses
      if(t >= SPACING){ t = 0; k++; }
    }
    requestAnimationFrame(stepPulse);
  }
  // kick
  requestAnimationFrame(stepPulse);

  // Start with first pulse (even if paused)
  if(pulses.length){
    const p0 = pulses[0];
    ticker.textContent = `${p0.title} — ${p0.date || '—'}`;
    renderState(p0.tags);
  }
})();
</script>
