<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Tag Pulses)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:12px;left:12px;display:flex;gap:8px;align-items:center;background:#0f141b;border:1px solid #223;padding:8px 10px;border-radius:10px;z-index:10}
  button,select{background:#131a22;border:1px solid #2a3442;color:#e6edf3;border-radius:8px;padding:6px 10px;cursor:pointer}
  button.active{outline:2px solid #6ea8ff}
  #legend{opacity:.7;font-size:12px}
  #ticker{position:fixed;right:12px;top:12px;background:#0f141b;border:1px solid #223;padding:6px 10px;border-radius:10px;font-size:12px;opacity:.9;z-index:10;max-width:40ch}
  #warn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a212b;border:1px solid #334;padding:14px 16px;border-radius:12px;font-size:14px;display:none;max-width:520px}
  canvas{display:block;width:100%;height:100%}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>0.5</option><option selected>1.0</option><option>1.5</option><option>2.0</option>
    </select>
  </label>
  <span id="legend">URL: <code>?half=3&spacing=5&autoplay=1</code></span>
</div>
<div id="ticker">—</div>
<div id="warn"></div>
<canvas id="c"></canvas>

<script>
(async function(){
  // -------- URL knobs --------
  const q = new URLSearchParams(location.search);
  const HALF = +q.get('half')    || 3.0;  // seconds half-life (τ = HALF/ln2)
  const GAP  = +q.get('spacing') || 5.0;  // seconds between pulse events
  const AUTOPLAY = q.get('autoplay') === '1';
  const TAU = HALF / Math.log(2);

  const warn = (msg) => {
    const el = document.getElementById('warn');
    el.textContent = msg;
    el.style.display = 'block';
  };

  // -------- Ensure PHI_DATA (from docs/data.js) --------
  async function ensurePHIData(timeoutMs=2500){
    if (window.PHI_DATA && typeof window.PHI_DATA==='object') return window.PHI_DATA;

    if (!document.querySelector('script[data-role="phi-data"]')){
      const s = document.createElement('script');
      s.src = 'data.js';
      s.async = true;
      s.dataset.role = 'phi-data';
      document.head.appendChild(s);
    }

    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs){
      if (window.PHI_DATA && typeof window.PHI_DATA==='object') return window.PHI_DATA;
      await new Promise(r=>setTimeout(r, 60));
    }
    return null;
  }

  const D = await ensurePHIData();
  if(!D || !Array.isArray(D.nodes) || !Array.isArray(D.links)){
    warn("Tag data not found.\n\nTip: run “Build Tags & Graph” to regenerate docs/data.js, then reload.\nThis page expects window.PHI_DATA provided by docs/data.js.");
    console.error('PHI_DATA missing; ensure docs/data.js defines window.PHI_DATA.');
    return;
  }

  // -------- Index + robust positions (x|fx|nx, y|fy|ny) --------
  const idx = new Map(D.nodes.map((n,i)=>[n.id,i]));
  let pos = D.nodes.map(n => ({
    x: (n.x ?? n.fx ?? n.nx ?? 0),
    y: (n.y ?? n.fy ?? n.ny ?? 0),
  }));

  const minX=Math.min(...pos.map(p=>p.x)), maxX=Math.max(...pos.map(p=>p.x));
  const minY=Math.min(...pos.map(p=>p.y)), maxY=Math.max(...pos.map(p=>p.y));
  const dx=(maxX-minX)||1, dy=(maxY-minY)||1;

  // Normalize to [0..1]
  pos = pos.map(p => ({x:(p.x-minX)/dx, y:(p.y-minY)/dy}));

  console.log('[gradient_map] nodes:', D.nodes.length, 'links:', D.links.length);
  console.log('[gradient_map] min/max x,y:', {minX,maxX,minY,maxY});

  // Resolve links to indices
  const links = D.links.map(l => {
    const a = idx.get(typeof l.source==='object' ? l.source.id : l.source);
    const b = idx.get(typeof l.target==='object' ? l.target.id : l.target);
    return (a!=null && b!=null) ? {a,b} : null;
  }).filter(Boolean);

  // -------- Build time-ordered pulse events from pulsesByTag --------
  function parseDate(s){
    if(!s) return null;
    const m = String(s).match(/^(\d{4})-(\d{2})-(\d{2})/);
    if(!m) return null;
    return new Date(+m[1], +m[2]-1, +m[3]);
  }

  const evRaw = [];
  if (D.pulsesByTag && typeof D.pulsesByTag==='object'){
    for (const [tag, arr] of Object.entries(D.pulsesByTag)){
      if(!Array.isArray(arr)) continue;
      for (const p of arr){
        const dt = parseDate(p && p.date);
        if (dt && idx.has(tag)) evRaw.push({tag, date: dt, title: p.title||'Pulse', dateStr: p.date, weight: p.weight||1});
      }
    }
  }
  evRaw.sort((a,b)=>a.date - b.date);

  const events = evRaw.map((e,k)=>({ node: idx.get(e.tag), t:k*GAP, meta:e }));

  // Fallback if no dated pulses: animate top-central tags
  if (!events.length){
    const top = [...D.nodes]
      .map((n,i)=>({i, c: (typeof n.centrality==='number'? n.centrality : 0)}))
      .sort((a,b)=>b.c-a.c)
      .slice(0,24);
    top.forEach((o,k)=>events.push({node:o.i, t:k*GAP, meta:{tag:D.nodes[o.i].id, title:'—', dateStr:''}}));
  }

  // Group fires by node
  const fires = Array.from({length:D.nodes.length}, ()=>[]);
  for (const ev of events){ if (ev.node!=null) fires[ev.node].push({t:ev.t, w:(ev.meta.weight||1)}); }

  // -------- Canvas + transform --------
  const C = document.getElementById('c'), X = C.getContext('2d');
  function fit(){
    const dpr = devicePixelRatio || 1;
    C.width = innerWidth * dpr;
    C.height = innerHeight * dpr;
    X.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  addEventListener('resize',fit,{passive:true}); fit();

  // Layout transform to viewport with margin
  const M = 0.05; // margin fraction
  const tx = p => ({
    x: (M + (1-2*M)*p.x) * innerWidth,
    y: (M + (1-2*M)*p.y) * innerHeight
  });

  // -------- Playback --------
  let t=0, playing=AUTOPLAY;
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const speedSel = document.getElementById('speed');

  function setButtons(){
    playBtn.classList.toggle('active', playing);
    pauseBtn.classList.toggle('active', !playing);
  }
  playBtn.onclick  = () => { playing=true; setButtons(); };
  pauseBtn.onclick = () => { playing=false; setButtons(); };
  setButtons();

  function now(){ return performance.now()/1000 }
  let last = now();

  const ticker = document.getElementById('ticker');
  function updateTicker(time){
    if (!events.length){ ticker.textContent='—'; return; }
    const k = Math.max(0, Math.min(events.length-1, Math.floor(time/GAP)));
    const m = events[k].meta || {};
    ticker.textContent = `${m.title || 'Pulse'}${m.dateStr ? ' — '+m.dateStr : ''}`;
  }

  function nodeIntensity(i, time){
    let s = 0;
    const ts = fires[i];
    for (let k=ts.length-1; k>=0; k--){
      const age = time - ts[k].t; if (age < 0) continue;
      const w = ts[k].w * Math.exp(-age/TAU);
      if (w < 1e-3) break; // too old to matter
      s += w;
    }
    return s;
  }

  function frame(){
    const n = now(), dt = Math.min(0.05, n-last); last = n;
    if (playing) t += dt * (+speedSel.value);

    // intensities
    const I = new Float32Array(D.nodes.length);
    for (let i=0;i<I.length;i++) I[i] = nodeIntensity(i, t);

    // draw
    X.clearRect(0,0,C.width,C.height);

    // frame & center crosshair (debug visual)
    X.strokeStyle = 'rgba(120,140,170,.25)';
    X.lineWidth = 1;
    X.strokeRect(0.5,0.5, innerWidth-1, innerHeight-1);
    X.beginPath(); X.moveTo(innerWidth/2-8, innerHeight/2); X.lineTo(innerWidth/2+8, innerHeight/2); X.stroke();
    X.beginPath(); X.moveTo(innerWidth/2, innerHeight/2-8); X.lineTo(innerWidth/2, innerHeight/2+8); X.stroke();

    // links
    X.lineWidth = 1.25;
    for (const {a,b} of links){
      const A = tx(pos[a]), B = tx(pos[b]);
      const glow = Math.min(1, I[a]*I[b]);
      X.strokeStyle = `rgba(122,162,247,${0.18 + 0.34*glow})`;
      X.beginPath(); X.moveTo(A.x,A.y); X.lineTo(B.x,B.y); X.stroke();
    }

    // nodes
    for (let i=0;i<D.nodes.length;i++){
      const p = tx(pos[i]);
      const j = Math.min(1, I[i]);
      const r = 4 + 12*j;

      if (j>0){
        const g = X.createRadialGradient(p.x,p.y, r*0.4, p.x,p.y, r);
        g.addColorStop(0, `rgba(145,200,255,${0.22*j})`);
        g.addColorStop(1, `rgba(145,200,255,0)`);
        X.fillStyle = g;
        X.beginPath(); X.arc(p.x,p.y,r,0,Math.PI*2); X.fill();
      }
      X.fillStyle = `rgba(200,230,255,${0.50 + 0.45*j})`;
      X.beginPath(); X.arc(p.x,p.y, 2.5 + 2*j, 0, Math.PI*2); X.fill();
    }

    updateTicker(t);
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
