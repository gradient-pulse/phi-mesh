<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Pulse-Driven Clusters)</title>
<style>
  :root{
    --bg:#0b0f14; --fg:#e6edf3;
    --panel:#0f141b; --muted:#a5b1c6;
    --ink:#9fb7d8; --active:#d9ecff;
    --ui:#1a2635; --ui-border:#2f4b6a; --ui-accent:#3fa3ff;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100%;height:100%}

  #ui{position:fixed;top:12px;left:12px;display:flex;gap:8px;align-items:center;
      background:var(--panel);border:1px solid var(--ui-border);padding:8px 10px;border-radius:12px}
  button,select{background:var(--ui);border:1.5px solid var(--ui-accent);color:var(--fg);
      border-radius:10px;padding:6px 12px;cursor:pointer}

  #pulsebox{position:fixed;right:12px;top:12px;background:var(--panel);
      border:1px solid var(--ui-border);border-radius:12px;padding:10px 12px;max-width:min(48ch,44vw)}
  #cap{font-size:12px;color:var(--muted);margin-bottom:4px}
  #title{font-size:13px;color:var(--fg);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>0.5</option><option selected>1.0</option><option>1.5</option><option>2.0</option>
    </select>
  </label>
</div>

<div id="pulsebox">
  <div id="cap">Pulse-driven tag clusters: each pulse lights its tags and their links.</div>
  <div id="title">—</div>
</div>

<canvas id="c" aria-label="Pulse-driven tag clusters"></canvas>

<!-- Same source as tag_map: exposes window.PHI_DATA -->
<script src="data.js"></script>
<script>
(async function(){
  // -------- URL knobs --------
  const q = new URLSearchParams(location.search);
  const HALF = +(q.get('half')||3.0);     // seconds half-life (for later use)
  const PACE = +(q.get('spacing')||6.0);  // seconds between pulses
  const AUTOPLAY = q.get('autoplay')==='1';

  // -------- Inputs --------
  const PHI = (window.PHI_DATA && typeof window.PHI_DATA==='object') ? window.PHI_DATA : {nodes:[],links:[]};
  const events = await fetch('./echoes.json').then(r=>r.json()).catch(()=>({events:[]})).then(x=>x.events||[]);

  // -------- Nodes/links + layout fallback --------
  const rawNodes = Array.isArray(PHI.nodes) ? PHI.nodes : [];
  const nodes = rawNodes.map(n => ({ id:n.id, x:n.x, y:n.y, centrality:n.centrality }));
  const id2i = new Map(nodes.map((n,i)=>[n.id,i]));
  const links = (PHI.links||[]).map(e=>{
    const a = id2i.get(e.source), b = id2i.get(e.target);
    return (a!=null && b!=null) ? {a,b} : null;
  }).filter(Boolean);

  // Do we have usable positions?
  const hasXY = nodes.length && nodes.some(n => Number.isFinite(n.x) && Number.isFinite(n.y));
  if(!hasXY){
    // Radial fallback: sort by centrality (or degree), place around a circle
    const degree = new Map();
    for(const e of links){ degree.set(e.a,(degree.get(e.a)||0)+1); degree.set(e.b,(degree.get(e.b)||0)+1); }
    const score = i => Number.isFinite(nodes[i].centrality) ? nodes[i].centrality : (degree.get(i)||0);
    const order = nodes.map((_,i)=>i).sort((a,b)=>score(b)-score(a));
    const N = nodes.length;
    for(let k=0;k<N;k++){
      const i = order[k];
      const ang = 2*Math.PI*(k/N);
      nodes[i].x = Math.cos(ang);
      nodes[i].y = Math.sin(ang);
    }
  }

  // Normalize -> [0,1] box
  const minX = Math.min(...nodes.map(n=>n.x)), maxX = Math.max(...nodes.map(n=>n.x));
  const minY = Math.min(...nodes.map(n=>n.y)), maxY = Math.max(...nodes.map(n=>n.y));
  const dx = (maxX-minX)||1, dy = (maxY-minY)||1;
  nodes.forEach(n => { n.nx = (n.x-minX)/dx; n.ny = (n.y-minY)/dy; });

  // Centrality max for sizing
  const cMax = nodes.reduce((m,n)=>Math.max(m, Number.isFinite(n.centrality)?n.centrality:0), 0) || 1;

  // -------- Canvas + pan/zoom --------
  const C = document.getElementById('c'), X = C.getContext('2d');
  function fit(){ C.width = innerWidth*devicePixelRatio; C.height = innerHeight*devicePixelRatio; draw(true); }
  addEventListener('resize', fit, {passive:true}); fit();

  let k = Math.min(C.width, C.height)/1.25;
  let tx = (C.width - k)/2, ty = (C.height - k)/2;
  let dragging=false, lx=0, ly=0;

  C.addEventListener('mousedown', e=>{ dragging=true; lx=e.clientX; ly=e.clientY; });
  addEventListener('mouseup',   ()=> dragging=false);
  addEventListener('mousemove', e=>{
    if(!dragging) return;
    tx += (e.clientX-lx)*devicePixelRatio;
    ty += (e.clientY-ly)*devicePixelRatio;
    lx=e.clientX; ly=e.clientY; draw(true);
  });
  C.addEventListener('wheel', e=>{
    e.preventDefault();
    const s = Math.exp(-e.deltaY/450);
    const mx = e.clientX*devicePixelRatio, my = e.clientY*devicePixelRatio;
    tx = mx - s*(mx - tx); ty = my - s*(my - ty); k *= s; draw(true);
  }, {passive:false});

  function P(n){ return { x: tx + n.nx*k, y: ty + n.ny*k }; }

  // -------- Timeline --------
  const timeline = events.map((ev,i)=>({
    title: ev.title || 'Pulse',
    date:  ev.date  || '',
    tags:  Array.isArray(ev.tags) ? ev.tags.filter(t=>id2i.has(t)) : [],
    t: i*PACE
  }));
  const pulseSets = timeline.map(p => new Set(p.tags));

  // -------- UI --------
  let playing = AUTOPLAY;
  document.getElementById('play').onclick = ()=> playing = true;
  document.getElementById('pause').onclick= ()=> playing = false;
  const speedSel = document.getElementById('speed');
  const titleEl = document.getElementById('title');
  function setPulseTitle(s){ titleEl.textContent = s; }

  // -------- Animation --------
  let t = 0, last = performance.now()/1000;
  function iPulseAt(tt){ if(!timeline.length) return -1; return Math.min(timeline.length-1, Math.floor(tt/ PACE)); }

  function draw(full=false){
    X.setTransform(1,0,0,1,0,0);
    X.clearRect(0,0,C.width,C.height);

    // Background links
    X.lineWidth = 1; X.globalAlpha = 0.08; X.strokeStyle = "#9fb7d8";
    for(const e of links){
      const a = P(nodes[e.a]), b = P(nodes[e.b]);
      X.beginPath(); X.moveTo(a.x,a.y); X.lineTo(b.x,b.y); X.stroke();
    }
    // Background nodes
    X.globalAlpha = 0.20;
    for(const n of nodes){
      const p = P(n);
      X.beginPath(); X.arc(p.x,p.y, 3, 0, Math.PI*2);
      X.fillStyle = "#9fb7d8"; X.fill();
    }
    X.globalAlpha = 1.0;

    // Active pulse cluster
    const ip = iPulseAt(t);
    const pulse = timeline[ip];
    if(pulse){
      setPulseTitle(`${pulse.title} — ${pulse.date}`);
      const active = pulseSets[ip];

      // Links within active cluster
      X.globalAlpha = 0.30; X.lineWidth = 1.3; X.strokeStyle = "#cfe6ff";
      for(const e of links){
        const aId = nodes[e.a].id, bId = nodes[e.b].id;
        if(active.has(aId) && active.has(bId)){
          const a = P(nodes[e.a]), b = P(nodes[e.b]);
          X.beginPath(); X.moveTo(a.x,a.y); X.lineTo(b.x,b.y); X.stroke();
        }
      }
      // Active nodes + labels
      for(const n of nodes){
        if(!active.has(n.id)) continue;
        const p = P(n);
        const r = 4.5 + 6*( (Number.isFinite(n.centrality)?n.centrality:0) / cMax );
        X.beginPath(); X.arc(p.x,p.y, r, 0, Math.PI*2);
        X.fillStyle = "#d9ecff"; X.globalAlpha = 0.95; X.fill();

        X.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        X.fillStyle = "rgba(230,240,255,0.9)";
        X.textAlign = "left"; X.textBaseline = "middle";
        X.fillText(n.id, p.x + r + 5, p.y);
      }
      X.globalAlpha = 1.0;
    } else {
      setPulseTitle("—");
    }
  }

  function tick(){
    const now = performance.now()/1000, dt = Math.min(0.05, now-last); last = now;
    if(playing) t += dt*(+speedSel.value || 1);
    draw();
    requestAnimationFrame(tick);
  }
  draw(true); tick();
})();
</script>
