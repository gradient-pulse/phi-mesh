<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Gradient Map (Pulse Echo)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --panel:#0f141b; --ink:#e6edf3;
    --muted:#9fb2c9; --edge:#7aa2f7; --edge-dim:#5a6e8c;
    --node:#a7cdfc; --node-dim:#3a4a61; --lit:#ffd399;
    --chip:#0f141b; --chip-b:#213044; --chip-on:#2d4965;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);
    font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:12px;left:12px;display:flex;gap:8px;align-items:center;
    background:var(--panel);border:1px solid #223; padding:8px 10px;border-radius:10px}
  button,select{background:var(--chip);border:1px solid var(--chip-b);
    color:var(--ink);border-radius:10px;padding:6px 10px;cursor:pointer}
  button.active{outline:2px solid var(--chip-on)}
  label{color:var(--muted)}
  #hint{position:fixed;top:12px;right:12px;max-width:520px;
    background:var(--panel);border:1px solid #223;border-radius:12px;
    padding:12px 14px}
  #hint h4{margin:0 0 6px 0;font-weight:700}
  #hint p{margin:0;color:var(--muted);font-size:12.5px}
  #pulse{position:fixed;top:62px;right:12px;background:var(--panel);
    border:1px solid #223;border-radius:12px;padding:8px 10px;color:var(--muted)}
  svg{width:100%;height:100%;display:block}
  .edge{stroke:var(--edge-dim);stroke-opacity:.12}
  .edge.hot{stroke:var(--edge);stroke-opacity:.55}
  .node{fill:var(--node-dim)}
  .node.lit{fill:var(--node)}
  .label{font-size:12px;fill:#bcd7ff;pointer-events:none;opacity:.0}
  .label.show{opacity:.9}
</style>

<div id="ui">
  <button id="play">▶︎ Play</button>
  <button id="pause">⏸︎ Pause</button>
  <label>Speed
    <select id="speed">
      <option>1.0</option>
      <option>2.0</option>
      <option>3.0</option>
    </select>
  </label>
</div>

<div id="hint">
  <h4>Pulse Gradient History: Tags Ignited</h4>
  <p>Each pulse is a gradient. As it passes, its tags ignite; only links between lit tags intensify. Pan/zoom is live.</p>
</div>
<div id="pulse">—</div>

<svg id="view" role="img" aria-label="Gradient Map — Pulse Echo">
  <g id="root">
    <g id="edges"></g>
    <g id="nodes"></g>
    <g id="labels"></g>
  </g>
</svg>

<!-- data.js should set window.PHI_DATA = {nodes:[{id,x,y,centrality?}], links:[{source,target}] } -->
<script src="data.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
(async function(){
  // ---- URL knobs --------------------------------------------------------
  const q = new URLSearchParams(location.search);
  const AUTOPLAY = q.get('autoplay') === '1';
  let   SPACING  = +(q.get('spacing') || 2);     // seconds per pulse @ 1×
  const SPEEDSEL = document.getElementById('speed');
  SPEEDSEL.value = (q.get('speed') || '1.0');

  // ---- Data -------------------------------------------------------------
  const DATA = (window.PHI_DATA && typeof window.PHI_DATA === 'object')
    ? window.PHI_DATA : {nodes:[],links:[]};

  const pulses = await fetch('./echoes.json')
    .then(r => r.json())
    .then(j => Array.isArray(j.events) ? j.events : [])
    .catch(()=>[]);

  // Guard
  if (!DATA.nodes?.length) {
    console.error('[gradient_map] No nodes found (PHI_DATA missing).');
  }

  // ---- Build index & scales --------------------------------------------
  const idToNode = new Map(DATA.nodes.map(n=>[n.id,n]));
  const W = document.documentElement.clientWidth;
  const H = document.documentElement.clientHeight;
  const pad = 40;

  const xs = DATA.nodes.map(n=>+n.x || 0);
  const ys = DATA.nodes.map(n=>+n.y || 0);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  // Treat coordinates as normalized if they look like 0..1
  const normalized = (maxX <= 1.2 && minX >= -0.2 && maxY <= 1.2 && minY >= -0.2);
  const sx = d3.scaleLinear().domain([minX, maxX]).range([pad, W - pad]);
  const sy = d3.scaleLinear().domain([minY, maxY]).range([pad, H - pad]);
  const nx = n => {
    const x = (+n.x || 0);
    return normalized ? x * (W - 2*pad) + pad : sx(x);
  };
  const ny = n => {
    const y = (+n.y || 0);
    return normalized ? y * (H - 2*pad) + pad : sy(y);
  };

  // Derived nodes/links with fixed positions
  const nodes = DATA.nodes.map(n => ({
    id: n.id,
    x: nx(n),
    y: ny(n),
    r: 4 + Math.sqrt(Math.max(1, (n.centrality ?? 1))) * 1.6
  }));

  const nodeById = new Map(nodes.map(n=>[n.id,n]));
  const links = DATA.links.map(l => {
    const a = (typeof l.source === 'object') ? l.source.id : l.source;
    const b = (typeof l.target === 'object') ? l.target.id : l.target;
    const A = nodeById.get(a), B = nodeById.get(b);
    return (A && B) ? {source:A, target:B} : null;
  }).filter(Boolean);

  // ---- SVG layers & zoom -----------------------------------------------
  const svg = d3.select('#view');
  const root = d3.select('#root');
  svg.call(
    d3.zoom().scaleExtent([0.35, 4]).on('zoom', ev => {
      root.attr('transform', ev.transform);
    })
  );

  // draw edges (static, we’ll toggle classes)
  const edgeSel = d3.select('#edges')
    .selectAll('line').data(links)
    .join('line')
    .attr('class','edge')
    .attr('x1',d=>d.source.x).attr('y1',d=>d.source.y)
    .attr('x2',d=>d.target.x).attr('y2',d=>d.target.y)
    .attr('stroke-width',1);

  // draw nodes
  const nodeSel = d3.select('#nodes')
    .selectAll('circle').data(nodes, d=>d.id)
    .join('circle')
    .attr('class','node')
    .attr('r',d=>d.r)
    .attr('cx',d=>d.x).attr('cy',d=>d.y);

  // labels (only shown for lit nodes)
  const labelSel = d3.select('#labels')
    .selectAll('text').data(nodes, d=>d.id)
    .join('text')
    .attr('class','label')
    .attr('text-anchor','middle')
    .attr('x',d=>d.x)
    .attr('y',d=>d.y - (d.r + 6))
    .text(d=>d.id);

  // ---- Pulse playback ---------------------------------------------------
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const pulseBadge = document.getElementById('pulse');

  let playing = AUTOPLAY;
  playBtn.classList.toggle('active', playing);
  pauseBtn.classList.toggle('active', !playing);

  playBtn.onclick = () => { playing = true;  playBtn.classList.add('active'); pauseBtn.classList.remove('active'); };
  pauseBtn.onclick= () => { playing = false; pauseBtn.classList.add('active'); playBtn.classList.remove('active'); };

  // render a pulse index
  function renderPulse(k){
    const ev = pulses[k];
    if (!ev) { pulseBadge.textContent = '—'; return; }

    pulseBadge.textContent = `${ev.title || 'Pulse'} — ${ev.date || ''}`;

    const lit = new Set((ev.tags||[]).filter(t => nodeById.has(t)));

    // nodes: lit vs dim
    nodeSel.classed('lit', d => lit.has(d.id));

    // labels only for lit nodes
    labelSel.classed('show', d => lit.has(d.id));

    // edges: emphasize if both endpoints lit; otherwise faint (but still visible)
    edgeSel
      .classed('hot', d => (lit.has(d.source.id) && lit.has(d.target.id)))
      .attr('stroke-width', d => (lit.has(d.source.id) && lit.has(d.target.id)) ? 1.6 : 1.0);
  }

  // timeline
  let i = 0;
  let last = performance.now()/1000;
  function tick(){
    const now = performance.now()/1000;
    const dt = now - last; last = now;
    const speed = +SPEEDSEL.value || 1.0;

    if (playing && pulses.length){
      // advance when wall time exceeds spacing/speed
      if (!tick._acc) tick._acc = 0;
      tick._acc += dt;
      if (tick._acc >= (SPACING / speed)){
        tick._acc = 0;
        i = (i + 1) % pulses.length;
      }
    }
    renderPulse(i);
    requestAnimationFrame(tick);
  }
  renderPulse(i);
  requestAnimationFrame(tick);
})();
</script>
