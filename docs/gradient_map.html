<!doctype html>
<meta charset="utf-8" />
<title>Φ-Mesh — Pulsed Gradient History</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg:#0b0f14; --panel:#0f141b; --ink:#e6edf3; --muted:#9fb0c3;
    --line:#a9bfda; --hot:#d9ecff; --pill:#142034; --pill-b:#2a3b52;
    --accent:#7fbaff;
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--ink);
              font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial }
  canvas { display:block; width:100%; height:100% }

  /* UI ------------------------------------------------------------- */
  #ui { position:fixed; top:14px; left:14px; display:flex; gap:10px; z-index:5 }
  .btn, .sel {
    background: #0f1824; color:var(--ink); border:1px solid #2a3b52;
    border-radius:12px; padding:8px 12px; cursor:pointer; height:34px;
    display:flex; align-items:center; gap:8px; box-shadow:0 1px 0 rgba(255,255,255,.03) inset;
  }
  .btn:active { transform:translateY(1px) }
  .btn[data-on="1"] { outline:2px solid #24456e }
  .sel select {
    appearance:none; background:transparent; color:var(--ink); border:none;
    font:inherit; padding-right:18px; cursor:pointer;
  }

  #hud {
    position:fixed; top:14px; right:14px; z-index:5;
    background:linear-gradient(180deg,rgba(20,25,34,.95),rgba(16,21,30,.92));
    border:1px solid #263648; border-radius:14px; padding:12px 14px; max-width:520px;
    box-shadow:0 12px 40px rgba(0,0,0,.35);
  }
  #title { font-weight:700; margin-bottom:8px }
  #expl { color:var(--muted); font-size:13px; }
  #pulsepill {
    display:inline-flex; align-items:center; gap:8px; margin-top:10px;
    background:var(--pill); border:1px solid var(--pill-b);
    padding:8px 10px; border-radius:999px; font-size:13px;
    white-space:nowrap; color:#cfe5ff;
  }
  #pulsepill b { color:#e6f2ff; }

  /* small watermark / fallback message */
  #warn {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    color:#9eb1c6; opacity:.9; font-size:15px; text-align:center; max-width:680px;
    background:rgba(20,26,36,.6); border:1px solid rgba(60,80,110,.5);
    border-radius:14px; padding:16px 18px; display:none; z-index:6;
  }
</style>

<div id="ui">
  <button id="play" class="btn" aria-label="Play">▶︎ Play</button>
  <button id="pause" class="btn" aria-label="Pause">⏸︎ Pause</button>
  <div class="sel btn" title="Playback speed">
    <span>Speed</span>
    <select id="speed">
      <option>1.0</option>
      <option>2.0</option>
      <option>3.0</option>
    </select>
  </div>
</div>

<div id="hud">
  <div id="title">Pulsed Gradient History: Tags Ignited</div>
  <div id="expl">Each pulse is a gradient. As it passes, its tags ignite; only links
    between lit tags intensify. Pan/zoom is live.</div>
  <div id="pulsepill"><b>Pulse —</b> <span id="pulselabel">—</span></div>
</div>

<div id="warn"></div>

<canvas id="c" aria-label="Pulsed gradient tag map"></canvas>
<script src="data.js"></script>
<script>
(function(){
  // ---------- URL knobs ----------
  const q = new URLSearchParams(location.search);
  const HALF  = +q.get('half')     || 3.0;   // seconds half-life for per-pulse fade
  const PACE  = +q.get('spacing')  || 6.0;   // seconds per pulse step
  const AUTO  = q.get('autoplay')  === '1';  // start playing

  // ---------- Data plumbing ----------
  // Expect window.PHI_DATA: { nodes:[{id,x,y,centrality?}], links:[{source,target}], pulsesByTag:{ tag:[{title,date,id?}...] } }
  const DATA = (window.PHI_DATA && typeof window.PHI_DATA === 'object') ? window.PHI_DATA : null;
  const warn = document.getElementById('warn');

  if(!DATA || !Array.isArray(DATA.nodes) || !Array.isArray(DATA.links)){
    warn.style.display='block';
    warn.textContent = "No PHI_DATA found. Open tag_map first or ensure docs/data.js defines window.PHI_DATA = { nodes, links, pulsesByTag }.";
    return;
  }

  // Build pulse timeline by scanning pulsesByTag
  const pulseMap = new Map(); // key -> {title,date,tags:Set}
  if (DATA.pulsesByTag && typeof DATA.pulsesByTag === 'object'){
    for (const [tag, list] of Object.entries(DATA.pulsesByTag)){
      if (!Array.isArray(list)) continue;
      for (const p of list){
        const title = p?.title || p?.id || 'Pulse';
        const date  = p?.date  || '';
        const key   = `${title}||${date}`;
        let obj = pulseMap.get(key);
        if (!obj){ obj = { title, date, tags:new Set() }; pulseMap.set(key,obj); }
        obj.tags.add(tag);
      }
    }
  }
  // Fall back: no pulses available
  if (pulseMap.size === 0){
    warn.style.display='block';
    warn.textContent = "No pulses found in PHI_DATA.pulsesByTag. The gradient playback needs pulses.";
    return;
  }

  // Order pulses by date asc (fallback to title)
  const pulses = Array.from(pulseMap.values()).sort((a,b)=>{
    const ad=a.date||'', bd=b.date||'';
    if (ad && bd) return ad.localeCompare(bd);
    if (ad) return -1; if (bd) return 1;
    return (a.title||'').localeCompare(b.title||'');
  });

  // Node index & positions
  const idx = new Map(DATA.nodes.map((n,i)=>[n.id,i]));
  const N   = DATA.nodes.length;
  const pos = DATA.nodes.map(n=>({
    x: (n.x ?? n.fx ?? n.nx ?? 0),
    y: (n.y ?? n.fy ?? n.ny ?? 0)
  }));

  // Normalize to canvas coords
  const [minX,maxX] = [Math.min(...pos.map(p=>p.x)), Math.max(...pos.map(p=>p.x))];
  const [minY,maxY] = [Math.min(...pos.map(p=>p.y)), Math.max(...pos.map(p=>p.y))];
  const spanX = (maxX-minX)||1, spanY=(maxY-minY)||1;

  // Build adjacency for fast "links between lit nodes"
  const links = DATA.links.map(l=>{
    // links can be {source,target} as ids or objects
    const a = idx.get(typeof l.source==='object'?l.source.id:l.source);
    const b = idx.get(typeof l.target==='object'?l.target.id:l.target);
    return (a!=null && b!=null) ? [a,b] : null;
  }).filter(Boolean);

  // ---------- Canvas & pan/zoom ----------
  const C = document.getElementById('c');
  const X = C.getContext('2d');

  function fit(){
    const dpr = devicePixelRatio||1;
    C.width  = innerWidth*dpr;
    C.height = innerHeight*dpr;
    X.setTransform(dpr,0,0,dpr,0,0);
    draw(true); // immediate redraw on resize
  }
  addEventListener('resize', fit, {passive:true});
  fit();

  // Pan/zoom (simple, smooth)
  let zoom = 1.0, panX = 0, panY = 0;
  let isPanning = false, lastX=0, lastY=0;

  C.addEventListener('mousedown', e => { isPanning=true; lastX=e.clientX; lastY=e.clientY; });
  addEventListener('mouseup',   ()=> isPanning=false);
  addEventListener('mouseleave',()=> isPanning=false);
  addEventListener('mousemove', e=>{
    if(!isPanning) return;
    panX += e.clientX - lastX;
    panY += e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    draw(true);
  }, {passive:true});

  C.addEventListener('wheel', e=>{
    e.preventDefault();
    const Z = Math.exp(-e.deltaY*0.0015); // smooth zoom
    // zoom toward cursor
    const wx = (e.clientX - panX), wy = (e.clientY - panY);
    panX -= wx * (Z-1);
    panY -= wy * (Z-1);
    zoom *= Z;
    zoom = Math.max(0.3, Math.min(4.5, zoom));
    draw(true);
  }, {passive:false});

  function toCanvas(p){
    // center graph then scale
    const gx = (p.x - minX)/spanX * C.width/ (devicePixelRatio||1);
    const gy = (p.y - minY)/spanY * C.height/(devicePixelRatio||1);
    return { x: gx*zoom + panX, y: gy*zoom + panY };
  }

  // ---------- Pulse engine ----------
  // playback state
  const TAU = HALF/Math.log(2);
  let t=0, last=performance.now()/1000;
  let playing = AUTO;                       // start?
  let curPulse = 0;                         // index in pulses
  let speedSel = document.getElementById('speed');

  const ignited = new Float32Array(N);      // intensity per node (0..~1)

  function ageWeight(age){ return Math.exp(-age/TAU); } // time fade

  function tick(){
    const now = performance.now()/1000;
    const dt  = Math.min(0.05, now-last); last=now;
    if (playing) t += dt * (+speedSel.value||1);

    // Which pulse window are we in?
    const pulseIdx = Math.floor( t / PACE );
    if (pulseIdx !== curPulse && pulseIdx>=0 && pulseIdx < pulses.length){
      curPulse = pulseIdx;
      setPulseUI();
    }

    // decay all
    const decay = Math.exp(-dt/TAU);
    for (let i=0;i<N;i++) ignited[i] *= decay;

    // add current pulse energy
    const P = pulses[Math.max(0, Math.min(pulses.length-1, curPulse))];
    if (P && P.tags){
      for (const tag of P.tags){
        const i = idx.get(tag);
        if (i!=null) ignited[i] = Math.min(1, ignited[i] + 1.0*dt*(1.5/HALF));
      }
    }
    draw(false);
    requestAnimationFrame(tick);
  }

  // ---------- Drawing ----------
  function draw(fast){
    X.clearRect(0,0,C.width,C.height);

    // links: two passes (background, then lit->lit)
    // background (very soft)
    X.globalAlpha = 0.08;
    X.lineWidth = Math.max(1, 1.0*zoom);
    X.strokeStyle = '#9fb7d4';
    X.beginPath();
    for (const [a,b] of links){
      const A = toCanvas(pos[a]), B = toCanvas(pos[b]);
      X.moveTo(A.x,A.y); X.lineTo(B.x,B.y);
    }
    X.stroke();

    // intensified links (only between lit nodes, whiten & thicker)
    X.globalAlpha = 0.55;
    X.lineWidth = Math.max(1.5, 2.0*zoom);
    X.strokeStyle = '#e7f1ff';
    X.beginPath();
    for (const [a,b] of links){
      const ia = ignited[a], ib = ignited[b];
      if (ia>0.18 && ib>0.18){
        const A = toCanvas(pos[a]), B = toCanvas(pos[b]);
        X.moveTo(A.x,A.y); X.lineTo(B.x,B.y);
      }
    }
    X.stroke();

    // nodes (soft dot + brighter if ignited)
    for (let i=0;i<N;i++){
      const p = toCanvas(pos[i]);
      const hot = ignited[i];
      const r   = 3 + (hot>0.15 ? Math.min(10, 12*hot) : 0); // subtle growth
      // soft base
      X.globalAlpha = 0.18; X.fillStyle = '#9eb2cc';
      X.beginPath(); X.arc(p.x,p.y, 6, 0, Math.PI*2); X.fill();
      // core
      X.globalAlpha = hot>0.12 ? 0.9 : 0.45;
      X.fillStyle = hot>0.12 ? '#cfe6ff' : '#a7bfdc';
      X.beginPath(); X.arc(p.x,p.y, r, 0, Math.PI*2); X.fill();
    }

    // labels (always visible; brighten when ignited)
    X.font = `${Math.max(11, 12*zoom)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    X.textAlign = 'left'; X.textBaseline='middle';
    for (let i=0;i<N;i++){
      const p = toCanvas(pos[i]);
      const hot = ignited[i];
      X.globalAlpha = hot>0.15 ? 0.95 : 0.38;
      X.fillStyle = hot>0.15 ? '#e9f3ff' : '#a8b9cf';
      X.fillText(DATA.nodes[i].id, p.x + 8, p.y);
    }
  }

  // ---------- UI ----------
  const playBtn  = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const pill     = document.getElementById('pulselabel');

  function setPulseUI(){
    const P = pulses[Math.max(0, Math.min(pulses.length-1, curPulse))];
    const when = P.date ? ` — ${P.date}` : '';
    pill.textContent = `${P.title||'Pulse'}${when}`;
  }

  playBtn.onclick  = ()=>{ playing=true;  playBtn.dataset.on="1"; pauseBtn.dataset.on="0"; };
  pauseBtn.onclick = ()=>{ playing=false; playBtn.dataset.on="0"; pauseBtn.dataset.on="1"; };
  // init toggles
  (AUTO ? playBtn : pauseBtn).click();

  // Kick off
  setPulseUI();
  requestAnimationFrame(tick);
})();
</script>
